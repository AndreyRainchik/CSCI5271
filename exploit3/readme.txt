San Min Liew: liewx024@umn.edu
Andrey Rainchik: rainc001@umn.edu

This version of exploit.sh utilizes the macro function of sudobcvi to execute shellcode inside of an environment variable and open a root shell. The macro function has several limitations on it that can be found in the call_macro() function. These limitations include blacklisting the interrupt, call, and jump assembly instructions. The biggest impact is the interrupt blocker, as the shellcode to run rootshell requires an "int 0x80" to call the kernel and execute the shellcode. However, another macro can be written to go to an arbitrary memory address, and thus we can get the macro to execute our shellcode.

The shellcode in the environment variable PWN was written by calling execve(/bin/rootshell,NULL,NULL) in assembly. Additionally, a NOP sled of 8000 NOPs ensures that the macro run by sudobcvi will hit the shellcode. The macro was written by generating the assembly code to move a memory value to %EAX, push %EAX onto the stack, and then return, causing the program to execute the instructions found at that memory address. Since the address points to the NOP sled, it'll slide down until it reaches the shellcode and executes /bin/rootshell.

When the exploit script is run by a general user, it will assign the necessary values to the PWN environment variable, and generate a macro for sudobcvi to run. Then, it calls sudobcvi on the macro, shifts the cursor left by a few positions to get to the machine code, and runs it with R. This causes a root shell to pop.

